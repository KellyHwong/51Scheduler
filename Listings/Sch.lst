C51 COMPILER V9.54   SCH                                                                   05/23/2015 22:33:37 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE SCH
OBJECT MODULE PLACED IN .\Objects\Sch.obj
COMPILER INVOKED BY: D:\Program Files (x86)\Keil\C51\BIN\C51.EXE Sch.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT
                    -(.\Listings\Sch.lst) OBJECT(.\Objects\Sch.obj)

line level    source

   1          /**
   2          * @Filename:
   3          * @Created:
   4          * @Updated:
   5          * @Author: Kelly Hwong
   6          * @Description: Cooperative scheduler
   7          */
   8          #include "Main.h"
*** WARNING C312 IN LINE 110 OF Main.h: misplaced endif control
   9          #include "Port.h"
  10          
  11          #include "Sch51.h"
*** WARNING C318 IN LINE 11 OF Sch.c: can't open file 'Sch51.h'
  12          
  13          /** Public variables */
  14          //The array of tasks
  15          sTask SCH_tasks_G[SCH_MAX_TASKS];
*** ERROR C129 IN LINE 15 OF Sch.c: missing ';' before 'SCH_tasks_G'
  16          
  17          //Used to display the error code
  18          tByte Error_code_G = 0;
  19          
  20          /** Private function prototypes */
  21          static void SCH_Go_To_Sleep(void);
  22          
  23          /** Private variables*/
  24          //Keeps tracks of time since last error was recorded
  25          static tWord Error_tick_count_G;
  26          //The code of the last error
  27          static tByte Last_error_code_G;
  28          
  29          /** SCH_Dispatch_Tasks
  30          * the dispatch funtion. When a task is due to run,
  31          * SCH_Dispatch_Tasks() will run it.
  32          * This function must be called repeatedly in the
  33          * main loop.
  34          */
  35          void SCH_Dispatch_Tasks(void)
  36          {
  37              tByte Index;
  38          
  39              //Dispatches the next tast(if one is ready)
  40              for(Index = 0; Index < SCH_MAX_TASKS; Index++)
  41              {
  42                  if(SCH_tasks_G[Index].RunMe > 0)
  43                  {
  44                      //Run the task
  45                      (*SCH_tasks_G[Index].pTask)();
  46                      //Reset the RunMe flag
  47                      SCH_tasks_G[Index].RunMe -= 1;
  48          
  49                      //Periodic tasks will automatically run again
  50                      //But if this is a one-time task, remove it
  51                      //from the tasks array
C51 COMPILER V9.54   SCH                                                                   05/23/2015 22:33:37 PAGE 2   

  52                      if(SCH_tasks_G[Index].Period == 0)
  53                      {
  54                          SCH_Delete_Task(Index);
  55                      }
  56                  }
  57              }
  58              //Report system status
  59              SCH_Report_Status();
  60              //The scheduler enters idle mode
  61              SCH_Go_To_Sleep();
  62          }
  63          
  64          /*------------------------------------------------------------------*-
  65          
  66            SCH_Add_Task()
  67          
  68            Causes a task (function) to be executed at regular intervals
  69            or after a user-defined delay
  70          
  71            Fn_P   - The name of the function which is to be scheduled.
  72                     NOTE: All scheduled functions must be 'void, void' -
  73                     that is, they must take no parameters, and have
  74                     a void return type.
  75          
  76            DELAY  - The interval (TICKS) before the task is first executed
  77          
  78            PERIOD - If 'PERIOD' is 0, the function is only called once,
  79                     at the time determined by 'DELAY'.  If PERIOD is non-zero,
  80                     then the function is called repeatedly at an interval
  81                     determined by the value of PERIOD (see below for examples
  82                     which should help clarify this).
  83          
  84          
  85            RETURN VALUE:
  86          
  87            Returns the position in the task array at which the task has been
  88            added.  If the return value is SCH_MAX_TASKS then the task could
  89            not be added to the array (there was insufficient space).  If the
  90            return value is < SCH_MAX_TASKS, then the task was added
  91            successfully.
  92          
  93            Note: this return value may be required, if a task is
  94            to be subsequently deleted - see SCH_Delete_Task().
  95          
  96            EXAMPLES:
  97          
  98            Task_ID = SCH_Add_Task(Do_X,1000,0);
  99            Causes the function Do_X() to be executed once after 1000 sch ticks.
 100          
 101            Task_ID = SCH_Add_Task(Do_X,0,1000);
 102            Causes the function Do_X() to be executed regularly, every 1000 sch ticks.
 103          
 104            Task_ID = SCH_Add_Task(Do_X,300,1000);
 105            Causes the function Do_X() to be executed regularly, every 1000 ticks.
 106            Task will be first executed at T = 300 ticks, then 1300, 2300, etc.
 107          
 108          -*------------------------------------------------------------------*/
 109          tByte SCH_Add_Task(void (code * pFunction))(void),
 110                              const tWord DELAY,
 111                              const tWord PERIOD)
 112          {
 113              tByte Index = 0;
C51 COMPILER V9.54   SCH                                                                   05/23/2015 22:33:37 PAGE 3   

 114              while((0!=SCH_tasks_G[Index].pTask)&&(Index < SCH_MAX_TASKS))
 115              {
 116                  Index++;
 117              }
 118              if(SCH_MAX_TASKS==Index)
 119              {
 120                  //Tast list is full
 121                  //Set the global error variable
 122                  Error_code_G = ERROR_SCH_TOO_MANY_TASKS;
 123          
 124                  //Also return an error code
 125                  return SCH_MAX_TASKS;
 126              }
 127              //If we're here, there must be a space in the task array
 128              SCH_tasks_G[Index].pTask = pFunction;
 129              SCH_tasks_G[Index].Delay = DELAY;
 130              SCH_tasks_G[Index].Period = PERIOD;
 131              SCH_tasks_G[Index].RunMe = 0;
 132          
 133              //return position of task, in case to delete it later
 134              //if we have to
 135              return Index;
 136          }
 137          
 138          /*------------------------------------------------------------------*-
 139          
 140            SCH_Delete_Task()
 141          
 142            Removes a task from the scheduler.  Note that this does
 143            *not* delete the associated function from memory:
 144            it simply means that it is no longer called by the scheduler.
 145          
 146            TASK_INDEX - The task index.  Provided by SCH_Add_Task().
 147          
 148            RETURN VALUE:  RETURN_ERROR or RETURN_NORMAL
 149          
 150          -*------------------------------------------------------------------*/
 151          bit SCH_Delete_Task(const tByte TASK_INDEX)
 152          {
 153              bit Return_code;
 154              if(0==SCH_tasks_G[TASK_INDEX].pTask)
 155              {
 156                  //Set the global error variable
 157                  Error_code_G = ERROR_SCH_CANNOT_DELETE_TASK;
 158                  //Also return a error code
 159                  Return_code = RETURN_ERROR;
 160              }
 161              else
 162              {
 163                  Return_code = RETURN_NORMAL;
 164              }
 165              SCH_tasks_G[TASK_INDEX].pTask = 0x0000;
 166              SCH_tasks_G[TASK_INDEX].Delay = 0;
 167              SCH_tasks_G[TASK_INDEX].Period = 0;
 168              SCH_tasks_G[TASK_INDEX].RunMe = 0;
 169          
 170              return Return_code;
 171          }
 172          
 173          /*------------------------------------------------------------------*-
 174          
 175            SCH_Report_Status()
C51 COMPILER V9.54   SCH                                                                   05/23/2015 22:33:37 PAGE 4   

 176          
 177            Simple function to display error codes.
 178          
 179            This version displays code on a port with attached LEDs:
 180            adapt, if required, to report errors over serial link, etc.
 181          
 182            Errors are only displayed for a limited period
 183            (60000 ticks = 1 minute at 1ms tick interval).
 184            After this the the error code is reset to 0.
 185          
 186            This code may be easily adapted to display the last
 187            error 'for ever': this may be appropriate in your
 188            application.
 189          
 190            See Chapter 10 for further information.
 191          
 192          -*------------------------------------------------------------------*/
 193          void SCH_Report_Status(void)
 194          {
 195          #ifdef SCH_REPORT_ERRORS
 196             // ONLY APPLIES IF WE ARE REPORTING ERRORS
 197             // Check for a new error code
 198             if (Error_code_G != Last_error_code_G)
 199                {
 200                // Negative logic on LEDs assumed
 201                Error_port = 255 - Error_code_G;
 202          
 203                Last_error_code_G = Error_code_G;
 204          
 205                if (Error_code_G != 0)
 206                   {
 207                   Error_tick_count_G = 60000;
 208                   }
 209                else
 210                   {
 211                   Error_tick_count_G = 0;
 212                   }
 213                }
 214             else
 215                {
 216                if (Error_tick_count_G != 0)
 217                   {
 218                   if (--Error_tick_count_G == 0)
 219                      {
 220                      Error_code_G = 0; // Reset error code
 221                      }
 222                   }
 223                }
 224          #endif
 225          }
 226          
 227          void SCH_Go_To_Sleep()
 228          {
 229             PCON |= 0x01;    // Enter idle mode (generic 8051 version)
 230             //51的话0x01是休眠模式，0x02是掉电模式
 231          
 232             // Entering idle mode requires TWO consecutive instructions
 233             // on 80c515 / 80c505 - to avoid accidental triggering
 234             //PCON |= 0x01;    // Enter idle mode (#1)
 235             //PCON |= 0x20;    // Enter idle mode (#2)
 236          }

C51 COMPILATION COMPLETE.  2 WARNING(S),  1 ERROR(S)
