C51 COMPILER V9.54   SCH51                                                                 05/23/2015 22:58:34 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE SCH51
OBJECT MODULE PLACED IN .\Objects\Sch51.obj
COMPILER INVOKED BY: D:\Program Files (x86)\Keil\C51\BIN\C51.EXE Sch51.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRI
                    -NT(.\Listings\Sch51.lst) OBJECT(.\Objects\Sch51.obj)

line level    source

   1          /**
   2          * @Filename:
   3          * @Created:
   4          * @Updated:
   5          * @Author: Kelly Hwong
   6          * @Description: Cooperative scheduler
   7          */
   8          #include "Main.h"
*** WARNING C312 IN LINE 110 OF Main.h: misplaced endif control
   9          #include "Port.h"
  10          #include "Sch51.h"
  11          
  12          /** Public variables */
  13          //The array of tasks
  14          sTask SCH_tasks_G[SCH_MAX_TASKS];
  15          
  16          //Used to display the error code
  17          tByte Error_code_G = 0;
  18          
  19          /** Private function prototypes */
  20          static void SCH_Go_To_Sleep(void);
  21          
  22          /** Private variables*/
  23          //Keeps tracks of time since last error was recorded
  24          static tWord Error_tick_count_G;
  25          //The code of the last error
  26          static tByte Last_error_code_G;
  27          
  28          /** SCH_Dispatch_Tasks
  29          * the dispatch funtion. When a task is due to run,
  30          * SCH_Dispatch_Tasks() will run it.
  31          * This function must be called repeatedly in the
  32          * main loop.
  33          */
  34          void SCH_Dispatch_Tasks(void)
  35          {
  36   1          tByte Index;
  37   1      
  38   1          //Dispatches the next tast(if one is ready)
  39   1          for(Index = 0; Index < SCH_MAX_TASKS; Index++)
  40   1          {
  41   2              if(SCH_tasks_G[Index].RunMe > 0)
  42   2              {
  43   3                  //Run the task
  44   3                  (*SCH_tasks_G[Index].pTask)();
  45   3                  //Reset the RunMe flag
  46   3                  SCH_tasks_G[Index].RunMe -= 1;
  47   3      
  48   3                  //Periodic tasks will automatically run again
  49   3                  //But if this is a one-time task, remove it
  50   3                  //from the tasks array
  51   3                  if(SCH_tasks_G[Index].Period == 0)
  52   3                  {
  53   4                      SCH_Delete_Task(Index);
C51 COMPILER V9.54   SCH51                                                                 05/23/2015 22:58:34 PAGE 2   

  54   4                  }
  55   3              }
  56   2          }
  57   1          //Report system status
  58   1          SCH_Report_Status();
  59   1          //The scheduler enters idle mode
  60   1          SCH_Go_To_Sleep();
  61   1      }
  62          
  63          /*------------------------------------------------------------------*-
  64          
  65            SCH_Add_Task()
  66          
  67            Causes a task (function) to be executed at regular intervals
  68            or after a user-defined delay
  69          
  70            Fn_P   - The name of the function which is to be scheduled.
  71                     NOTE: All scheduled functions must be 'void, void' -
  72                     that is, they must take no parameters, and have
  73                     a void return type.
  74          
  75            DELAY  - The interval (TICKS) before the task is first executed
  76          
  77            PERIOD - If 'PERIOD' is 0, the function is only called once,
  78                     at the time determined by 'DELAY'.  If PERIOD is non-zero,
  79                     then the function is called repeatedly at an interval
  80                     determined by the value of PERIOD (see below for examples
  81                     which should help clarify this).
  82          
  83          
  84            RETURN VALUE:
  85          
  86            Returns the position in the task array at which the task has been
  87            added.  If the return value is SCH_MAX_TASKS then the task could
  88            not be added to the array (there was insufficient space).  If the
  89            return value is < SCH_MAX_TASKS, then the task was added
  90            successfully.
  91          
  92            Note: this return value may be required, if a task is
  93            to be subsequently deleted - see SCH_Delete_Task().
  94          
  95            EXAMPLES:
  96          
  97            Task_ID = SCH_Add_Task(Do_X,1000,0);
  98            Causes the function Do_X() to be executed once after 1000 sch ticks.
  99          
 100            Task_ID = SCH_Add_Task(Do_X,0,1000);
 101            Causes the function Do_X() to be executed regularly, every 1000 sch ticks.
 102          
 103            Task_ID = SCH_Add_Task(Do_X,300,1000);
 104            Causes the function Do_X() to be executed regularly, every 1000 ticks.
 105            Task will be first executed at T = 300 ticks, then 1300, 2300, etc.
 106          
 107          -*------------------------------------------------------------------*/
 108          tByte SCH_Add_Task(void (code * pFunction)(), 
 109                             const tWord DELAY, 
 110                             const tWord PERIOD)    
 111          {
 112   1          tByte Index = 0;
 113   1         while ((SCH_tasks_G[Index].pTask != 0) && (Index < SCH_MAX_TASKS))
 114   1          {
 115   2              Index++;
C51 COMPILER V9.54   SCH51                                                                 05/23/2015 22:58:34 PAGE 3   

 116   2          }
 117   1          if(SCH_MAX_TASKS==Index)
 118   1          {
 119   2              //Tast list is full
 120   2              //Set the global error variable
 121   2              Error_code_G = ERROR_SCH_TOO_MANY_TASKS;
 122   2      
 123   2              //Also return an error code
 124   2              return SCH_MAX_TASKS;
 125   2          }
 126   1          //If we're here, there must be a space in the task array
 127   1          SCH_tasks_G[Index].pTask = pFunction;
 128   1          SCH_tasks_G[Index].Delay = DELAY;
 129   1          SCH_tasks_G[Index].Period = PERIOD;
 130   1          SCH_tasks_G[Index].RunMe = 0;
 131   1      
 132   1          //return position of task, in case to delete it later
 133   1          //if we have to
 134   1          return Index;
 135   1      }
 136          
 137          /*------------------------------------------------------------------*-
 138          
 139            SCH_Delete_Task()
 140          
 141            Removes a task from the scheduler.  Note that this does
 142            *not* delete the associated function from memory:
 143            it simply means that it is no longer called by the scheduler.
 144          
 145            TASK_INDEX - The task index.  Provided by SCH_Add_Task().
 146          
 147            RETURN VALUE:  RETURN_ERROR or RETURN_NORMAL
 148          
 149          -*------------------------------------------------------------------*/
 150          bit SCH_Delete_Task(const tByte TASK_INDEX)
 151          {
 152   1          bit Return_code;
 153   1          if(0==SCH_tasks_G[TASK_INDEX].pTask)
 154   1          {
 155   2              //Set the global error variable
 156   2              Error_code_G = ERROR_SCH_CANNOT_DELETE_TASK;
 157   2              //Also return a error code
 158   2              Return_code = RETURN_ERROR;
 159   2          }
 160   1          else
 161   1          {
 162   2              Return_code = RETURN_NORMAL;
 163   2          }
 164   1          SCH_tasks_G[TASK_INDEX].pTask = 0x0000;
 165   1          SCH_tasks_G[TASK_INDEX].Delay = 0;
 166   1          SCH_tasks_G[TASK_INDEX].Period = 0;
 167   1          SCH_tasks_G[TASK_INDEX].RunMe = 0;
 168   1      
 169   1          return Return_code;
 170   1      }
 171          
 172          /*------------------------------------------------------------------*-
 173          
 174            SCH_Report_Status()
 175          
 176            Simple function to display error codes.
 177          
C51 COMPILER V9.54   SCH51                                                                 05/23/2015 22:58:34 PAGE 4   

 178            This version displays code on a port with attached LEDs:
 179            adapt, if required, to report errors over serial link, etc.
 180          
 181            Errors are only displayed for a limited period
 182            (60000 ticks = 1 minute at 1ms tick interval).
 183            After this the the error code is reset to 0.
 184          
 185            This code may be easily adapted to display the last
 186            error 'for ever': this may be appropriate in your
 187            application.
 188          
 189            See Chapter 10 for further information.
 190          
 191          -*------------------------------------------------------------------*/
 192          void SCH_Report_Status(void)
 193          {
 194   1      #ifdef SCH_REPORT_ERRORS
 195   1         // ONLY APPLIES IF WE ARE REPORTING ERRORS
 196   1         // Check for a new error code
 197   1         if (Error_code_G != Last_error_code_G)
 198   1            {
 199   2            // Negative logic on LEDs assumed
 200   2            Error_port = 255 - Error_code_G;
 201   2      
 202   2            Last_error_code_G = Error_code_G;
 203   2      
 204   2            if (Error_code_G != 0)
 205   2               {
 206   3               Error_tick_count_G = 60000;
 207   3               }
 208   2            else
 209   2               {
 210   3               Error_tick_count_G = 0;
 211   3               }
 212   2            }
 213   1         else
 214   1            {
 215   2            if (Error_tick_count_G != 0)
 216   2               {
 217   3               if (--Error_tick_count_G == 0)
 218   3                  {
 219   4                  Error_code_G = 0; // Reset error code
 220   4                  }
 221   3               }
 222   2            }
 223   1      #endif
 224   1      }
 225          
 226          void SCH_Go_To_Sleep()
 227          {
 228   1         PCON |= 0x01;    // Enter idle mode (generic 8051 version)
 229   1         //51的话0x01是休眠模式，0x02是掉电模式
 230   1      
 231   1         // Entering idle mode requires TWO consecutive instructions
 232   1         // on 80c515 / 80c505 - to avoid accidental triggering
 233   1         //PCON |= 0x01;    // Enter idle mode (#1)
 234   1         //PCON |= 0x20;    // Enter idle mode (#2)
 235   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    306    ----
C51 COMPILER V9.54   SCH51                                                                 05/23/2015 22:58:34 PAGE 5   

   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     39       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
